#### 数组

#### 数组的基本方法

##### 数组拼接
concat() 方法用于连接两个或多个数组。
```javascript
  var a = ['1', '2', '3']
  var b = ['4', '5']
  a.concat(b) // ["1", "2", "3", "4", "5"]
```

##### 将数组元素拼接成字符串
join() 方法用于把数组中的所有元素连接成一个字符串。join()方法可以通过参数指定的分隔符，不指定时使用','号分隔。
```javascript
  var a = ['abc', 'def', 'ghi']
  a.join('$') // "abc$def$ghi"
```

##### 删除数组的第一个元素
shift() 方法用于把数组的第一个元素从其中删除，并返回第一个元素的值
```javascript
  var a = [1, 2, 3]
  a.shift() // 1
```

##### 删除数组中最后一个元素
pop() 方法用于删除并返回数组的最后一个元素
```javascript
  var a = [1, 2, 3]
  a.pop() // 3
```

##### 向数组头部添加元素
unshift() 方法可向数组的开头添加一个或更多元素，并返回新的长度
```javascript
var colors = ['red', 'green', 'blue'];
console.log(colors.unshift('black'));		//4
console.log(colors);		//[ 'black', 'red', 'green', 'blue' ]
```

##### 向数组尾部添加元素
push() 方法可向数组的末尾添加一个或多个元素，并返回新的长度。
```javascript
  var a = [1, 2, 3]
  a.push(4) // 4
```
##### 数组元素反向排序
reverse() 方法用于颠倒数组中元素的顺序
```javascript
  var a = [1, 2, 3]
  a.reverse() // [3, 2, 1]
```

##### 截取数组
slice(start, end) 方法可从已有的数组中返回选定的元素。返回从start索引开始，end索引结束的所有元素。
```javascript
  var a = [1, 2, 3, 4]
  a.slice(1, 3) // [2, 3]
```

##### 数组排序
sort(sortby) 方法用于对数组的元素进行排序。sortby参数可选，规定排序顺序，必须是函数
```javascript
var colors = ['red', 'green', 'blue'];
console.log(colors.sort());   //[ 'blue', 'green', 'red' ]

var students = [{name:'x', age:7}, {name:'y', age:9}, {name:'z', age:6}]
students.sort(function(a,b){
	return a.age > b.age;
});
//[ { name: 'z', age: 6 },{ name: 'x', age: 7 },{ name: 'y', age: 9 } ]
```

##### 数组元素替换
splice(index,howmany,item1,.....,itemX) 方法向/从数组中添加/删除项目，然后返回被删除的项目。该方法会改变原始数组
```javascript
//从数组第1索引位开始，删除两个元素，并添加'black项'
var colors = ['red', 'green', 'blue'];
console.log(colors.splice(1,2, 'black'));		//[ 'green', 'blue' ]
console.log(colors);       //[ 'red', 'black' ]
```

##### 元素的遍历、循环
forEach() 方法用数组中的每个元素调用一次提供的回调函数。
> orEach 方法按升序为数组中含有效值的每一项执行一次callback 函数，那些已删除（使用delete方法等情况）或者从未赋值的项将被跳过（但不包括哪些值为 undefined 的项）。

forEach 遍历的范围在第一次调用 callback 前就会确定。调用forEach 后添加到数组中的项不会被 callback 访问到。如果已经存在的值被改变，则传递给 callback 的值是 forEach 遍历到他们那一刻的值。已删除的项不会被遍历到。
```javascript
  var array = [1, 2, 3, 4]
  array.forEach(function(item, index, array){
    console.log(item, index, array)
  })
```

##### 元素重新复制，返回一个新函数
map 方法返回一个由原数组中的每个元素调用一个指定方法后的返回值组成的新数组。“映射” 一个新数组。
> map 方法会给原数组中的每个元素都按顺序调用一次 callback 函数。callback 每次执行后的返回值组合起来形成一个新数组。 callback 函数只会在有值的索引上被调用；那些从来没被赋过值或者使用 delete 删除的索引则不会被调用。map 不修改调用它的原数组本身（当然可以在 callback 执行时改变原数组）。


```javascript
  var array = [1, 2, 3, 4]
  var sop = array.map(function(item, index, array){
    return item * item
  })
  console.log(sop) // [1, 4, 9, 16]
```

##### 数组元素过滤
filter() 方法使用指定的函数测试所有元素，并返回一个包含所有通过测试的元素的新数组。
> filter 为数组中的每个元素调用一次 callback 函数，并利用所有使得 callback 返回 true 或 等价于 true 的值 的元素创建一个新数组。callback 只会在已经赋值的索引上被调用，对于那些已经被删除或者从未被赋值的索引不会被调用。那些没有通过 callback 测试的元素会被跳过，不会被包含在新数组中。

```javascript
function isBigEnough(element) {
  return element >= 10;
}
var filtered = [12, 5, 8, 130, 44].filter(isBigEnough);
// filtered is [12, 130, 44]
```

##### 元素递归、累加
reduce() 接收一个函数作为累加器（accumulator），数组中的每个值（从左到右）开始缩减，最终为一个值。
> reduce 为数组中的每一个元素依次执行回调函数，不包括数组中被删除或从未被赋值的元素，接受四个参数：初始值（或者上一次回调函数的返回值），当前元素值，当前索引，调用 reduce 的数组。
回调函数第一次执行时，previousValue 和 currentValue 可以是一个值，如果 initialValue 在调用 reduce 时被提供，那么第一个 previousValue 等于 initialValue ，并且currentValue 等于数组中的第一个值；如果initialValue 未被提供，那么previousValue 等于数组中的第一个值，currentValue等于数组中的第二个值。
如果数组为空并且没有提供initialValue， 会抛出TypeError 。如果数组仅有一个元素（无论位置如何）并且没有提供initialValue， 或者有提供initialValue但是数组为空，那么此唯一值将被返回并且callback不会被执行。

```javascript
var sum = [1, 2, 3, 4].reduce(function (previous, current, index, array) {
  return previous + current;
});
console.log(sum); // 10
//
var matrix = [
  [1, 2],
  [3, 4],
  [5, 6]
];
// 二维数组扁平化
var flatten = matrix.reduce(function (previous, current) {
  return previous.concat(current);
});
console.log(flatten); // [1, 2, 3, 4, 5, 6]

```

##### 数组子元素是否满足条件
some() 方法测试数组中的某些元素是否通过了指定函数的测试。
> some 为数组中的每一个元素执行一次 callback 函数，直到找到一个使得 callback 返回一个“真值”（即可转换为布尔值 true 的值）。如果找到了这样一个值，some 将会立即返回 true。否则，some 返回 false。callback 只会在那些”有值“的索引上被调用，不会在那些被删除或从来未被赋值的索引上调用。

```javascript
//检测在数组中是否有元素大于 10。
function isBigEnough(element, index, array) {
  return (element >= 10);
}
var passed = [2, 5, 8, 1, 4].some(isBigEnough);
// passed is false
passed = [12, 5, 8, 1, 4].some(isBigEnough);
// passed is true
```

##### 元素是否存在于数组里
```javascript
var data = [2, 5, 7, 3, 5];

console.log(data.indexOf(5, "3")); // 4 (从3号位开始搜索)
console.log(data.indexOf(4)); // -1 (未找到)
console.log(data.indexOf("5")); // -1 (未找到，因为5 !== "5")
//
console.log(data.lastIndexOf(5)); // 4
console.log(data.lastIndexOf(5, 3)); // 1 (从后往前，索引值小于3的开始搜索)
console.log(data.lastIndexOf(4)); // -1 (未找到)
```

##### 检测是否为数组
```javascript
  var arrayStr=new Array("1","2","3","4","5");
  alert(arrayStr instanceof Array);  //true
  //
  Array.isArray([]);
  Array.isArray([1]);
  Array.isArray(new Array());
  // 鲜为人知的事实：其实 Array.prototype 也是一个数组。
  Array.isArray(Array.prototype);
```

##### JS数组求并集，交集和差集
ES7 <br>
ES7新增了一个Array.prototype.includes的数组方法，用于返回一个数组是否包含指定元素，结合filter方法。
```javascript
  // 并集
  let union = a.concat(b.filter(v => !a.includes(v))) // [1,2,3,4,5]
  // 交集
  let intersection = a.filter(v => b.includes(v)) // [2]
  // 差集
  let difference = a.concat(b).filter(v => !a.includes(v) || !b.includes(v)) // [1,3,4,5]
```
ES5 <br>
ES5可以利用filter和indexOf进行数学集操作，但是，由于indexOf方法中NaN永远返回-1，所以需要进行兼容处理。
```javascript
  // 并集
  var union = a.concat(b.filter(function(v) {
  return a.indexOf(v) === -1})) // [1,2,3,4,5]
  // 交集
  var intersection = a.filter(function(v){ return b.indexOf(v) > -1 }) // [2]
  // 差集
  var difference = a.filter(function(v){ return b.indexOf(v) === -1 }).concat(b.filter(function(v){ return a.indexOf(v) === -1 })) // [1,3,4,5]
```

##### 数组排序
```javascript
  function shuffle(arr) {
     arr.sort(function () {
        return Math.random() - 0.5;
     });
  }
```

更精准的随机排训：<br>
ES5
```javascript
  function shuffle(arr) {
    var i = arr.length, t, j;
    while (i) {
      j = Math.floor(Math.random() * i--);
      t = arr[i];
      arr[i] = arr[j];
      arr[j] = t;
    }
  }
```
ES6 <br>
```javascript
  function shuffle(arr) {
    let i = arr.length;
    while (i) {
        let j = Math.floor(Math.random() * i--);
        [arr[j], arr[i]] = [arr[i], arr[j]];
    }
  }
```

##### 数组的复制
```javascript
var arr1 = [1, 2, 3, 4]
	arr2 = arr1.slice(0)
	arr3 = arr1.concat()
  console.log(arr1, arr2, arr3) // [1, 2, 3, 4]
  // 深度复制

  // 使用 JSON.parse(JSON.stringify(arr))
  var arr1 = [1, 2, [3, 4], {a: 5, b: 6}, 7]
	arr2 = JSON.parse(JSON.stringify(arr1))
  console.log(arr1, arr2)
  // 如果数组元素为函数，会丢失

  //自定义的复制方法
  function clone() {
    var copy = (this instanceof Array) ? [] : {};
    for (var attr in this) {
      if (this.hasOwnProperty(attr)){
        copy[attr] = typeof(this[attr])==='object' ? clone(this[attr]) : this[attr];
      }
    }
    return copy;
  };
```

##### 数组去重
```javascript
  var arr = [1, 2, 3, 4, 5, 5, 5, 5];
  var res = [];
  arr.forEach((d) => {
    if(res.indexOf(d) === -1) {
      res.push(d)
    }
  });
  //
  // ES6
  let arr = ['a', 'b', 'c' , 'a', 'c', 'd'];
  let res = Array.from(new Set(arr));
```
