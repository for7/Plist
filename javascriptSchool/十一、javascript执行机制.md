## javascript执行机制

上一节我们讲了 javascript 解析引擎。本节我们讲一下 javascript 代码是如何解析执行我们编写的 js 源代码的。

在很多教程里讲到 javascript 引擎是一行一行的执行代码的，即从第一行源代码开始顺序向下执行。但是在实际开发中对这个结论总是半信半疑。比如说像下面这样出现定时器又怎么去解释呢？

```javascript
let a = 1
setTimeout(function () {
    a =2
}, 1000)
console.log(a) // 1
```

得出 a 最终输出为1的结论往往是我们通过语法规则，`setTimeout`会延迟1000毫秒执行`a=2`表达式。浏览器提供的内置API`setTimeout`、`setinterval`都会延迟执行内部的代码，但是浏览器是基于什么机制去执行这些"特列"代码呢？

首先我们知道 javascript 是单线程并发语言，即同一时刻只能执行执行单个任务单元。即使理论上需要同步执行多个任务时 javascript 引擎运行时也是根据内部机制采用分步、分块的队列递进执行的。实际开发中的一些同步用法，实质上是用单线程与队列的方式去模拟多线程。

Event Loop(事件循环)

由于 javascript 运行时只有一个进程，我们称为为主进程（HTML5中提出了子进程（Web-Worke），但是子进程依然依附于主进程，javascript是单线程这一核心依然没变）。我们可以将javascript引擎看作是一个执行器，而所有的源代码的执行都由这一个执行器来完成。当页面载入时执行器会向上下文栈中压入全局对象。然后顺序执行全局对象下面的函数，当遇到函数时，会将函数（上下文）压入调用栈。函数运行完毕后会将该函数出栈，直到所有代码都运行完毕。当函数调用栈为空是就依赖于事件循环机制，从任务队列中提取回调函数压入调用栈中并执行。

我们先来看一个没有`Event Loop`参与的栗子：

```javascript
function foo () {
    
}
function too () {
    
}
function bar () {
    let a = 1
    too()
}

bar()
foo()
```

主要分析上下文栈的变化，我们先来梳理一下执行的不同节点上下文栈的状态：

1. 首先载入全局对象（全局上下文：初始化内置对象、全局属性/函数）；
2. 执行`bar`函数，将`bar`函数（上下文）压入（上下文）栈
3. 执行`bar`函数内代码
4. 发现`too`函数的调用，将`too`函数压入栈
5. 执行`too`函数内代码
6. `too`函数内代码执行完毕，`too`函数出栈
7. `bar`函数内代码执行完毕，`bar`函数出栈
8. 发现`foo`函数的调用，将`foo`函数压入栈
9. 执行`foo`函数内代码
10. `foo`函数内代码执行完毕，`foo`函数出栈

每个函数在调用时会被加入到栈顶部，当函数内部的所有代码执行完，函数会被从栈顶移出。用个形象的比如，这就像土拔鼠钻找花生，代码就是花生。马路上有一排洞，从近到远一个一个的钻，当遇到嵌套洞穴时也必须钻进去，洞穴里的花生都找完了就退出来，直至马路上都所用洞都被寻觅了一篇。执行器根据上下文关系将代码以栈的形式进行分层管理起来，并最终运行完所有代码。

熟悉了上下文的`change`后我们再对上面的实例代码做一点点改变：

```javascript
function foo () {
    
}
function too () {
    
}
function bar () {
    let a = 1
    setTimeout(function () {
        console.log('hello word')
    }, 1000)
    too()
}

bar()
foo()
```

这词我们在`bar`函数内部加入了一个定时器，1000ms后打印出`hello word`。这里异步代码的执行就是有`Event Loop`机制来执行的。

在此我们来通过存在`setTimeout`的情形，分析`javascript`的执行机制：

1. 执行`bar`函数，将`bar`函数（上下文）压入（上下文）栈
2. 执行`too`函数内代码
   1. 执行`a=1`语句
   2. 发现`setTimeout`标识符 > 解析为浏览器内置API setTimeout > 调用浏览器内核模块（webcore）> 调用**定时器线程模块**（timer), 加入一个1000ms倒计时任务
3. 发现`too`函数的调用，将`too`函数压入栈
4. 执行`too`函数内代码
5. `too`函数内代码执行完毕，`too`函数出栈
6. `bar`函数内代码执行完毕
7. 发现`foo`函数的调用，将`foo`函数压入栈
8. 执行`foo`函数内代码
9. `foo`函数内代码执行完毕，`foo`函数出栈
10. 所有同步任务执行完毕，主线程处于闲置状态。轮询异步队列
12. ​    ......
12. 浏览器内核**定时器线程模块**，1000ms倒计时结束 > 将回调函数扔入浏览器异步队列(Callback Queue)
13. 事件轮询（Event Loop）机制发现调用栈为空，且有可执行回调函数
14. 将回调函数压入栈
15. 执行回调函数内代码 > 打印输出`hello word`
16. 回调函数执行完毕，出栈
17. 所有同步任务执行完毕，轮询异步队列
18. ......


由此我们发现当`javascript`引擎遇到耗时的浏览器API执行时,也就是上面栗子中的`setTimeout`，会立即调用相应的浏览器内核API。当Event Loop检测到上下文栈中的代码都执行完毕，且异步队列中有可执行回调函数，会立即执行并将该函数加入到上下文栈中。所以这里定时器的回调函数会在大于或者等于1000毫秒之后执行：

1. 当执行到定时器后没有后续耗时的同步代码，即调用栈在到达1000ms时已经闲置，栈内没有其他可执行代码。此时定时器的回调函数进入异步队列后会立即被`Event Loop`发现并执行。
2. 当执行到定时器接着向下执行代码，后续还有耗时的同步任务（比如复杂的循环、递归）。此时定时器1000毫秒完毕将回调函数加入异步队列。但是由于还有未执行的同步任务，主线程依然被占用，回调函数不会被立即执行。所以这种情形下回调函数会在大于1000毫秒之后执行。

那么什么是事件循环(Event Loop)？

`Event Loop`在这里提供了一套机制用于在合适的时间执行异步的回调函数。javascript 本身对异步的支持，异步是由浏览器内核API提供, `Event Loop`事件循环提供了一套调用运行环境异步API后返回结果的机制。运行环境主要指浏览器、node环境。

所以我们可以将Event Loop看作是一个资源回收器，这种概念在一些前端框架中有体现，比如angran.js中的脏值检查机制。

为了加深对javascript异步处理机制的理解我们再来看个栗子：

```javascript
for (var i = 0; i < 5; i++) {
    setTimeout(function() {
        console.log(new Date, i);
    }, 1000);
}

？ // 求最后的打印值是多少
```

只要对 JS 中同步和异步代码的区别、变量作用域、闭包、参数传值等概念有正确的理解，就知道正确答案因该是'5,5,5,5,5'。简单来解释就是：`for`语句是同步语句，`setTimeout`是异步语句。`for`语句的循环会在一瞬间执行完毕，假设耗时是2ms。这2ms内会使用浏览器内核API创建5个定时任务，并且执行完后`i`的值为5。当大约1000ms后会将这5个定时器的回调函数加入异步队列，Event Loop检测有可执行回调函数后会调用回调函数，对表达式求值。由于回调函数内部没有定义变量`i`,也没有传入实参`i`,所以在当前函数的作用域找不到变量，根据作用域链向上查找发现外层作用域定义了变量`i`。最终每个回调函数被调用时取到的都是全局作用域的变量`i`,最终输出`5,5,5,5,5`。

不知道你理解了没有，如果没有可以会到前面章节继续了解一下作用域链、闭包等知识。

如果要求输出`0,1,2,3,4`该怎么修改呢？

其实根据上面的分析，我们已经知道原因出在回调函数执行时获取到的是外层作用域的的变量`i`，而外层作用域中的`i`在回调函数执行前就已经被赋值为5。所以我们需要做的就是截断回调函数执行时对外层变量`i`的访问。讲到这里大家估计已经猜到了该怎么修改了。

这里举例一个：

```javascript
for (var i = 0; i < 5; i++) {
    setTimeout(function() {
        console.log(new Date, i);
    }(i), 1000);
}

// 0 1 2 3 4
```

为了截断回调函数执行时对外层变量`i`的访问，我们在定时器执行时就依次将`i`的值以实参的形式传入回调函数的内部保存起来，这样回调函数在执行时取的就是当前作用域的`i`。

网上也有很多实现方式，但是原理都差不多，大家可以自行研究。

相信对javascript的执行机制有所了解，以后写代码的时候就更能得心印手了，bug也少了，至少不会很简单的用`setTimeout`去做电商网站的秒杀-_-

在javascript中除了`setTimeout`执行后会将回调函数加入异步队列实现延迟执行外，还有`setInterval`、`XMLHttpRequest`



##### 微任务

在ES6中提供了Promise用于表示异步操作，比如下面的栗子：

```javascript
var i = 1
setTimeout(function () {
        console.log('hello word')
}, 1000)

new Promise(function(resolve) {
    console.log('promise');
    resolve();
}).then(function() {
    console.log('then');
})

console.log(`hello word, ${i}`)

// 依次打印顺序
// promise
// hello word, 1
// then
// hello word
```

当执行到`new Promise`时，会调用浏览器内核API，并执行`Promise`里的回调函数，当回调函数内部返回状态时，会将状态对应的`then`回调函数加入微任务队列。

1. 浏览器执行，进入全都上下文
2. 代码第2行，遇到`setTimeout`，调用浏览器内核API
3. 执行`new Promise`， 打印输出`promise`，向下执行
4. 执行到`console`, 打印输出`hello word, 1`
5. 同步任务执行完毕，执行微任务队列
6. `then`语句的回调函数从微任务队列中取出，加入到上下文栈中。
7. 创建完上面回调函数的变量对象后，进入执行阶段，打印输出`then`
8. 回调函数执行完毕，函数出栈。将下一个微任务的回调函数加入上下文栈（这里这有一个微任务）
9. 所有微任务执行完毕，执行全局的异步队列（还是Event Loop机制）
10. 取出异步队列中`setTimeout`的回调函数，加入到上下文栈中执行
11. 打印输出`hell word`

微任务队列会比上面讲到的异步队列先触发执行。我们也可以将微任务队列看作是`局部任务队列`，所以当作用域内的同步代码执行完毕，会先执行局部任务队列里的回调函数，然后会去执行全局的异步队列。



