

## 变量对象

前面我们讲了上下文栈，知道在javascript引擎执行到函数的时候会向上下文栈（调用栈）中压入一个上下文。上下文中包含：

- 作用域链
- this
- 变量对象

```javascript
// 全局上下文的伪代码
windowEC = {
    VO: Window,
    scopeChain: {},
    this: Window
}
```

作用域链为函数提供上层可访问变量和函数的有序集合。 this为函数提供运行时对象环境。变量对象提供当前函数定义时的变量和函数。这一节我们主要来理清楚变量对象。

在上一篇文章中我们知道当函数被激活（调用）的时候，一个新的上下文会被创建。而一个执行上下文的生命周期分为两个阶段：

- 创建阶段： 在这个阶段上下文对象会创建变量对象、创建作用域链、确定 this 的指向。
- 直接阶段：创建完成后，就开始执行代码。这个时候会完成变量的赋值、表达式计算等。

下面我们会围绕这两个阶段来理解函数调用后发生的事情。



### 函数上下文

变量对象的创建会依次完成以下几个事情：

1. 生成 arguments 对象。检查当前上下文的形参，生成属性与属性值对象(key: value)
   - 当形参没有被赋值时， 属性值被设置为 undefined 
2. 在变量对象上建立函数索引。检查当前作用域定义的 function，在变量对象中以函数名为 key， 以函数所在内存地址为 value 建立索引。
   - 如果函数名已经在变量对象中，则该函数名对应的函数会被新的函数替换。所以函数可以被重复定义，后定义的函数会覆盖掉先前定义的。
3. 申明函数。检查当前作用域定义的变量，在变量对象中以变量名为 key， 以 undefined 为值挂载内部变量。
   - 如果新申明的变量名与已经申明的形参名、函数名相同，则申明会被抛弃。

由此可见函数申明比变量申明优先级高，一旦函数申明占用了某一个标识符，后续的变量申明如果使用的是先前使用过的函数标识符， 则该申明无效。

栗子1：

```javascript
function foo () {
    function too() {
    }
    var too
    console.log(typeof too)
}
foo()
// function
// 变量 too 的申明无效
```

我们把上面的栗子改一下， 栗子2：

```javascript
function foo () {
    function too() {
    }
    var too = 1
    console.log(typeof too)
}
foo()
// number
// 变量 too 的值类型为 number
```

变量 too 的值类型为 number,  看到这个栗子大家可能会疑惑， 因为更具上面的3条规则， too 的第二次申明应该是无效的且 too 的类型应该为 function。 其实 too 的值类型在上下文创建阶段确实是 function， 由于 javascript 是动态弱类型语言， 在上下文执行阶段 `var too = 1` 实质是在给 too 赋值并且发生了隐式类型转换， 所以在执行阶段 too 变成了 number 类型。es6 语法中已经不建议使用`var` 来申明变量了， 而是使用`let` 来申明局部变量，从语法层面强制避免了重复的变量申明， 栗子2中的情况会直接报错。

根据上面的规则理解变量提升就很简单了，随然很多文章都会提到函数执行时的变量提升问题，但是理解原理、知所以原更爽。我们再用伪代码来重现一下上下文创建阶段的细节。

```javascript
function foo () {
    console.log(a)
    console.log(bar)
    var a = 1
    function bar() {
        return 2
    }
}
foo()
// undefind
// ƒ bar() {
//      return 2
//  }
```

上下文扫面后会在变量对象上添加 ‘a’， ‘bar’ 两个标识符，此同时结束上下文的创建阶段进入执行阶段。在执行阶段foo 函数体第一行表达式要求打印输出 a 的值， 由于 `console.log(a)` 之前没有对 a 进行任何赋值操作，根据规则此时 a 的值为 undefind  所以输出 'undefind'。函数体内第二行要求打印输出 bar 的值，根据规则标识符 'bar' 对应的是函数，所以 'bar' 的值为函数实体，且在 `console.log(bar)` 之前也未对 bar 做赋值操作，所以打印出来的是该函数。

进入执行上下文后，创建完变量对象是这样的：

```javascript
// VO 为 Variable Object的缩写，即变量对象
VO = {
    arguments: {...},
    bar: <bar reference>  // 表示bar的地址引用
    a: undefined
}
```



### 全局上下文

在浏览器中，变量对象就是 window ，它也是全局对象，也可以通过 this 引用。全局对象提供浏览器预置对象，全局上下文的生命周期和函数的生命周期一样，只要程序运行不结束全局上下文就一直存在。其他所有的上下文环境，都能直接访问全局上下文的属性。

> 全局对象是预定义的对象，作为 JavaScript 的全局函数和全局属性的占位符。通过使用全局对象，可以访问所有其他所有预定义的对象、函数和属性。在顶层 JavaScript 代码中，可以用关键字 this 引用全局对象。因为全局对象是作用域链的头，这意味着所有非限定性的变量和函数名都会作为该对象的属性来查询。例如，当JavaScript 代码引用 parseInt() 函数时，它引用的是全局对象的 parseInt 属性。全局对象是作用域链的头，还意味着在顶层 JavaScript 代码中声明的所有变量都将成为全局对象的属性。