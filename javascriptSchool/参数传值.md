## 参数传值



平时开发中很多模凌两可的东西比较多，最好的学习方法就是抽时间把知识系统的整理出来。弄清楚知识点的来龙去脉，理清知识的忙点，做到有备无患。

参数传值也是 javascript 的一个需要注意的地方，很容易因为实参的数据类型而一些意想不到的情况。 下面我们来一起梳理一下。

网上有些栗子总结`javascript`分为按值传递和按引用传递, 即基本数据类型（原始数据类型）按值传递，引用数据类型按引用传递。在多数时候这句话是对的。这么说就是在有些时候并不是对的。

栗子1：

```javascript
let a = 1
function foo(x) {
    x = 2
    console.log(x)
}
foo(a)
console.log(a)
// 2
// 1
```

栗子1是按值传递的，变量` a `的值直接复制到了`foo`函数的实参`x`上，此时变量`x`是变量 a 的一个副本。它们独立保存了各自的值‘1’，且相互之间互不影响，我们对 a、x的读写操作，操作的是他们各自的内存地址值。


![用域 (3](C:\Users\luojh\Downloads\作用域 (3).png)

如图，在全局上下文（global）和`foo`的上下文栈中各自保存了独立的值`1`.

栗子2：

```javascript
let a = {
    abc: 1
}
function foo(x) {
    x.abc = 2
    console.log(x.abc)
}
foo(a)
console.log(a.abc)
// 2
// 2
```

根据编码经验我们会很自然的得出，上面的栗子是按引用传递。

按引用传值的情形： 对象`a`的引用被传递到函数foo内部， 函数内部变量`x`指向全局变量`a`，从而实现了引用的传递，所以变量`x`和变量`a`读写的是同一个对象。我们用一张图来揭示：

![用域 (4](C:\Users\luojh\Downloads\作用域 (4).png)

通过分析发现函数调用时值传递分为两种情况：基本数据类型传递的是值的字面量值，而引用类型传递的是被引用对象的标识符，就是我们称之的按引用传递。好像一切都很完美，故事到此就可以结束了。但是通过下面的栗子，你就会发现引用类型是按引用传递是有漏洞的。我们来看栗子：

```javascript
let a = {
    abc: 1
}
function foo(x) {
    x = 2
    console.log(x)
}
foo(a)
console.log(a.abc)
// 2
// 1
```

为什么会出现`a`、`x`在指向同一个对象后，`x`又不指向当初的对象呢？

准确的说基本类型按值传递，引用类型按共享传递（call by sharing）。分析一下上面代码执行时的内在机制：

foo 函数执行时， 形参 x 的值是传进去的对象 a 的内存地址引用，即在变量对象创建阶段`x`保存的是一个对象的内存地址。所以此时 a、x 都保存的是相同对象的内存地址引用。 接着在函数的执行阶段，代码的第一行将原始数据类型 2 赋值给 x，

 此时如果使用的是按引用传递 ，则变量 a 所指向的对象因该被赋值为2。但其实对 x 赋值为一个基本数据类型并没有使原对象为一个字面量值，这就说明引用类型并不是按引用传值，至少不是完整的遵从按引用传值来处理值的写入。

而我们区分说明存在两种不同的传值方式是因为被拷贝值的不同。函数传值时出现这一区别是因为申明变量时不同的内存分配方式。

- 原始数据类型：存储在栈（stack）中的简单数据段，也就是说，它们的值直接存储在**变量访问的位置**。这是因为这些原始类型占据的空间是固定的，所以可将他们存储在较小的内存区域 – 栈中。这样存储便于迅速查寻变量的值。
- 引用数据类型：存储在堆（heap）中的对象，也就是说，存储在变量处的值是一个指针（point），指向存储对象的内存地址。这是因为：引用值的大小会改变，所以不能把它放在栈中，否则会降低变量查寻的速度。相反，放在变量的栈空间中的值是该对象存储在堆中的地址。地址的大小是固定的，所以把它存储在栈中对变量性能无任何负面影响。

不同的内存分配机制也带来了不同的访问机制。

在javascript中是不允许直接访问保存在堆内存中的对象的，所以在访问一个对象时，首先得到的是这个对象在堆内存中的地址，然后再按照这个地址去获得这个对象中的值，这就是传说中的**按引用访问**。而原始类型的值则是可以直接访问到的。

那么到到底是按值传递还是按引用传递？

假设内存地址是一个字符串，变量 a 所引用的内存地址被复制给 foo 函数的内部变量 x， 此时变量a、x 都保存了同一个内存地址，当我们访问 a 和 x 的时候其实访问的是同一对象。

当然合理控制时间投入的追根到底才能有更大的进步， 如果上面的分析都理解透彻了， 是按什么传递已经不那么重要了，至少在编码的时候不会犯错了。



按共享传递 call by sharing，准确的说基本类型按值传递，引用类型按共享传递。 按共享传递与按引用传递的区别，是在函数内部对形参的赋值不会影响实参的值。此处需要一图来体会体会。

传共享调用本质上是传递对象的指针的拷贝，其指针也是变量的值。所以传共享调用也可以说是传值调用。



参考：

[javascript传递参](https://www.zhihu.com/question/27114726)

[JS是按值传递还是按引用传递?](http://bosn.me/js/js-call-by-sharing/)
