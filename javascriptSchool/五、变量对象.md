

# 变量对象

前面我们讲了上下文栈，javascript 引擎执行到函数的时候会向上下文栈中压入一个上下文。上下文中包含：

| name | - |
| ---- | - |
| 变量对象(VO, variable object)  | 当前函数定义的变量、函数、参数 |
| 作用域链(Scope chain)  | 源代码定义时形成的作用域链 |
| this  |   ||

伪代码：

```javascript
// 全局上下文的伪代码
windowEC = {
    VO: Window,
    scopeChain: {},
    this: Window
}
```



变量对象是函数运行时数据的集合，存储了在上下文中定义的变量和函数，不同的函数的变量对象稍有不同。

- 作用域链为当前函数提供上层可访问变量和函数的有序集合；
-  this为函数提供运行时对象环境；
- 变量对象提供当前函数定义时的变量和函数；



在`上下文`一章中我们知道当函数被调用的时候，一个新的上下文会被创建并加入到`上下文栈`的顶部。而一个执行上下文的生命周期分为两个阶段：

1. 创建阶段： 在这个阶段上下文对象会创建变量对象、创建作用域链、确定 this 的指向。
2. 运行阶段：创建完成后，就开始执行代码。这个时候会完成变量的赋值、表达式计算等。

即函数调用后会先通过创建上下文来收集函数运行时的资源，将其加入上下文栈后才会执行函数内部的表达式、语句。

```javascript
function foo (a) {
    var b = 1
    function c () {
        console.log(a + b) // 100
    }
}
foo(99)
```



foo 函数上下文中变量对象的示例图：

![](a3.png)

看图是最直接的，图中右边就是 foo 函数运行前变量对象创建后的示例图

上下文创建时候的`作用域链`的形成，和`this`的指向原则在前面的章节已经梳理过。javascript 中主要有全局上下文、函数上下文。下面我们梳理一下这两种上下文对应的变量对象。



### 函数上下文

变量对象的创建

1. 生成 arguments 对象。检查当前上下文的形参，生成属性与属性值对象(key: value)
   - 当形参没有被赋值时， 属性值被设置为 undefined
2. 在变量对象上建立函数索引。检查当前作用域定义的 function，在变量对象中以函数名为 key， 以函数所在内存地址为 value 建立索引。
   - 如果函数名已经在变量对象中，则该函数名对应的函数会被新的函数替换。所以函数可以被重复定义，后定义的函数会覆盖掉先前定义的。
3. 申明变量。检查当前作用域定义的变量，在变量对象中以变量名为 key， 以 undefined 为值挂载内部变量。
   - 如果新申明的变量名与已经申明的形参名、函数名相同，则申明会被抛弃。

由此可见函数申明比变量申明优先级高，一旦函数申明占用了某一个标识符，后续的变量申明如果使用的是先前使用过的函数标识符， 则该申明无效。



栗子1：

```javascript
function foo () {
    function too() {
    }
    var too
    console.log(typeof too)
}
foo()
// function
// 变量 too 的申明无效
```

我们把上面的栗子改一下， 栗子2：

```javascript
function foo () {
    function too() {
    }
    var too = 1
    console.log(typeof too)
}
foo()
// number
// 变量 too 的值类型为 number
```

变量 too 的值类型为 number,  看到这个栗子大家可能会疑惑， 因为更具上面的3条规则， too 的第二次申明应该是无效的且 too 的类型应该为 function。 其实 too 的值类型在上下文创建阶段确实是 function， 由于 javascript 是动态弱类型语言， 在上下文执行阶段 `var too = 1` 实质是在给 too 赋值并且发生了隐式类型转换， 所以在执行阶段 too 变成了 number 类型。es6 语法中已经不建议使用`var` 来申明变量了， 而是使用`let` 来申明局部变量，从语法层面强制避免了重复的变量申明， 栗子2中的情况会直接报错。

将上面的栗子稍作修改：

```javascript
function foo () {
    function too() {
    }
    console.log(typeof too) // function
    var too = 1
    console.log(typeof too) // number
}
foo()
```

foo 函数运行时会先打印 ‘function’，然后打印 ‘number’。首先表达式`console.log(typeof too)`执行时标识符`too`在上下文创建阶段被初始化为一个函数。`var too = 1`执行后标识符`too`被赋值为 1，所以第二次`console.log(typeof too)`的时候输出的是`number`.

根据上面的原则理解变量提升就要清晰很多了。我们用伪代码来模拟一下上下文创建阶段的细节。

```javascript
function foo () {
    console.log(a)
    console.log(bar)
    var a = 1
    function bar() {
        return 2
    }
}
foo()
// undefind
// ƒ bar() {
//      return 2
//  }
```

上下文创建阶段解析函数内代码块后，会在变量对象上添加 ‘a’， ‘bar’ 两个标识符，并填充相应的值结束上下文的创建阶段进入执行阶段。

在执行阶段foo 函数体第一行表达式要求打印输出 a 的值， 由于 `console.log(a)` 之前没有对 a 进行任何赋值操作，根据规则此时 a 的值为 `undefind`  所以输出 'undefind'。函数体内第二行要求打印输出 bar 的值，根据规则标识符 'bar' 对应的是函数，所以 'bar' 的值为函数实体，且在 `console.log(bar)` 之前也未对 bar 做赋值操作，所以打印出来的是该函数。

变量对象创建完，函数运行前的变量对象是这样的：

```javascript
// VO 为 Variable Object的缩写，即变量对象
VO = {
    arguments: {...},
    bar: <bar reference>  // 表示bar的地址引用
    a: undefined
}
```



### 全局上下文

在浏览器中，变量对象就是 window ，它也是全局对象，也可以通过 `this`和`self` 引用。全局对象提供浏览器预置对象，全局上下文的生命周期和函数的生命周期一样，只要程序运行不结束全局上下文就一直存在。其他所有的上下文环境，都能直接访问全局上下文的属性。

> 全局对象是预定义的对象，作为 JavaScript 的全局函数和全局属性的占位符。通过使用全局对象，可以访问所有其他所有预定义的对象、函数和属性。在顶层 JavaScript 代码中，可以用关键字 this 引用全局对象。因为全局对象是作用域链的头，这意味着所有非限定性的变量和函数名都会作为该对象的属性来查询。例如，当JavaScript 代码引用 parseInt() 函数时，它引用的是全局对象的 parseInt 属性。全局对象是作用域链的头，还意味着在顶层 JavaScript 代码中声明的所有变量都将成为全局对象的属性。
